{
  "folderName": "utils",
  "folderPath": ".autodoc/docs/json/src/cli/utils",
  "url": "https://github.com/context-labs/babyagi-ts/.autodoc/docs/json/src/cli/utils",
  "files": [
    {
      "fileName": "APIRateLimit.ts",
      "filePath": "src/cli/utils/APIRateLimit.ts",
      "url": "https://github.com/context-labs/babyagi-ts/src/cli/utils/APIRateLimit.ts",
      "summary": "The `APIRateLimit` class in this code snippet is designed to manage and limit the number of concurrent API calls made by the application. This is useful in scenarios where the API being called has a rate limit or when the application needs to control the number of simultaneous requests to avoid overloading the server.\n\nThe class has a constructor that takes an optional `maxConcurrentCalls` parameter, which defaults to 50. This parameter determines the maximum number of API calls that can be made concurrently.\n\nThe main method of this class is `callApi<T>(apiFunction: () => Promise<T>): Promise<T>`. This method takes a function `apiFunction` that returns a Promise, and it returns a new Promise. The purpose of this method is to queue the API calls and execute them in a controlled manner, ensuring that the number of concurrent calls does not exceed the specified limit.\n\nWhen `callApi` is called, it wraps the provided `apiFunction` in a new function `executeCall`, which is then added to the internal queue. If the number of in-progress calls is less than the maximum allowed, the `dequeueAndExecute` method is called to start processing the queued calls.\n\nThe `dequeueAndExecute` method dequeues and executes the API calls as long as there are calls in the queue and the number of in-progress calls is below the limit. When a call is executed, the `inProgress` counter is incremented, and the result of the API call is used to resolve or reject the Promise returned by `callApi`. Once the call is completed, the `inProgress` counter is decremented, and the `dequeueAndExecute` method is called again to process any remaining calls in the queue.\n\nHere's an example of how this class can be used:\n\n```typescript\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\n\nasync function fetchData(id: number): Promise<Data> {\n  // Make an API call to fetch data for the given ID\n}\n\nasync function fetchMultipleData(ids: number[]): Promise<Data[]> {\n  const results = await Promise.all(ids.map(id => apiRateLimiter.callApi(() => fetchData(id))));\n  return results;\n}\n```\n\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls made by the `fetchMultipleData` function, ensuring that no more than 10 calls are made at the same time.",
      "questions": "1. **What is the purpose of the `APIRateLimit` class?**\n\n   The `APIRateLimit` class is designed to manage and limit the number of concurrent API calls to a specified maximum, preventing the application from overwhelming the API with too many requests at once.\n\n2. **How does the `callApi` method work and what is its return type?**\n\n   The `callApi` method takes an `apiFunction` as an argument, which is a function that returns a Promise. It adds the API call to a queue and manages the execution of queued calls based on the maximum number of concurrent calls allowed. The method returns a Promise of type `T`, where `T` is the expected return type of the `apiFunction`.\n\n3. **How does the `dequeueAndExecute` method function?**\n\n   The `dequeueAndExecute` method is responsible for executing the queued API calls. It checks if there are any calls in the queue and if the number of in-progress calls is below the maximum allowed concurrent calls. If both conditions are met, it dequeues the next call and executes it. This method is called after each API call is completed to ensure that the queue is continuously processed."
    },
    {
      "fileName": "LLMUtil.ts",
      "filePath": "src/cli/utils/LLMUtil.ts",
      "url": "https://github.com/context-labs/babyagi-ts/src/cli/utils/LLMUtil.ts",
      "summary": "This code is responsible for interacting with the OpenAI API to generate embeddings and completions using different language models. It imports the necessary classes and types from the `openai` package and the project's `types.js` file. The code checks if the `OPENAI_API_KEY` environment variable is set, and initializes the `openai` instance with the API key.\n\nThe `models` object contains details about three different language models (GPT3, GPT4, and GPT432k), including their names, input and output costs per 1K tokens, and maximum token lengths.\n\nThe `createEmbedding` function takes a string as input and returns a Promise that resolves to an array of numbers representing the embedding. It calls the `openai.createEmbedding` method with the input string and the model name `text-embedding-ada-002`.\n\nThe `CreateCompletionParams` interface defines the parameters for the `createCompletion` function, which generates completions based on a given prompt and other optional parameters. The function constructs a `messages` array with a single system message containing the prompt, and sends a POST request to the OpenAI API's `/v1/chat/completions` endpoint with the necessary headers and parameters. It then extracts the completion result from the API response and returns it as a string.\n\nExample usage of these functions in the larger project might involve generating embeddings for text inputs or generating completions for prompts using the specified language models:\n\n```javascript\nconst embedding = await createEmbedding(\"This is a sample text.\");\nconsole.log(embedding);\n\nconst completion = await createCompletion({\n  model: LLMModels.GPT3,\n  prompt: \"Write a short story about a robot.\",\n  temperature: 0.7,\n  max_tokens: 100,\n});\nconsole.log(completion);\n```\n\nThese functions can be used to integrate the OpenAI API's capabilities into the babyagi-ts project, enabling it to generate embeddings and completions for various use cases.",
      "questions": "1. **Question:** What is the purpose of the `models` object and its properties?\n   **Answer:** The `models` object is a record that maps the names of different LLMModels (GPT3, GPT4, and GPT432k) to their respective details, such as name, inputCostPer1KTokens, outputCostPer1KTokens, and maxLength.\n\n2. **Question:** How does the `createEmbedding` function work and what does it return?\n   **Answer:** The `createEmbedding` function takes a string value as input and sends a request to the OpenAI API to create an embedding for the given input using the 'text-embedding-ada-002' model. It returns a Promise that resolves to an array of numbers representing the embedding.\n\n3. **Question:** What is the purpose of the `createCompletion` function and what parameters does it accept?\n   **Answer:** The `createCompletion` function is used to generate a completion for a given prompt using the OpenAI API. It accepts an object with properties such as model, prompt, temperature, max_tokens, top_p, frequency_penalty, and presence_penalty."
    },
    {
      "fileName": "WaitUtil.ts",
      "filePath": "src/cli/utils/WaitUtil.ts",
      "url": "https://github.com/context-labs/babyagi-ts/src/cli/utils/WaitUtil.ts",
      "summary": "The code in this file provides two utility functions, `wait` and `forTrue`, which are designed to help manage asynchronous operations in the larger babyagi-ts project. Both functions return Promises, making them suitable for use with `async/await` syntax.\n\n### wait function\n\nThe `wait` function takes two arguments: `timeoutMs`, which is the number of milliseconds to wait before resolving the Promise, and an optional `value` parameter, which defaults to `null`. The purpose of this function is to create a delay in the execution of asynchronous code. This can be useful in scenarios where you need to wait for a specific amount of time before proceeding with the next operation.\n\nExample usage:\n\n```javascript\nasync function example() {\n  console.log(\"Starting...\");\n  await wait(1000); // Wait for 1 second\n  console.log(\"...Finished\");\n}\n```\n\n### forTrue function\n\nThe `forTrue` function takes a single argument, `fn`, which is a function that returns a boolean value. The purpose of this function is to repeatedly check the result of the `fn` function until it returns `true` or a maximum number of attempts (200 in this case) is reached. The function checks the result of `fn` every 50 milliseconds. If `fn` returns `true`, the Promise resolves with the value `true`. If the maximum number of attempts is reached without `fn` returning `true`, the Promise is rejected.\n\nThis function can be useful in scenarios where you need to wait for a specific condition to be met before proceeding with the next operation, such as waiting for an element to be visible on a web page or for a specific value to be present in a data store.\n\nExample usage:\n\n```javascript\nasync function waitForElement() {\n  const elementExists = () => document.querySelector(\"#my-element\") !== null;\n  try {\n    await forTrue(elementExists);\n    console.log(\"Element found!\");\n  } catch {\n    console.log(\"Element not found after waiting\");\n  }\n}\n```\n\nIn summary, this file provides two utility functions that help manage asynchronous operations in the babyagi-ts project by introducing delays and waiting for specific conditions to be met.",
      "questions": "1. **What is the purpose of the `wait` function?**\n\n   The `wait` function is an asynchronous utility function that resolves a promise after a specified timeout in milliseconds, optionally returning a value when the promise resolves.\n\n2. **How does the `forTrue` function work and what is its use case?**\n\n   The `forTrue` function takes a function `fn` as an argument, which should return a boolean value. It repeatedly checks the result of `fn` every 50 milliseconds, and resolves a promise when `fn` returns `true`. It can be used to wait for a certain condition to become true before proceeding with the execution of the code.\n\n3. **Is there a limit to the number of times the `forTrue` function checks the result of `fn`?**\n\n   Yes, the `forTrue` function checks the result of `fn` up to 200 times. If `fn` does not return `true` within these 200 checks, the promise is rejected."
    }
  ],
  "folders": [],
  "summary": "The code in the `src/cli/utils` folder of the babyagi-ts project provides utility functions and classes to manage asynchronous operations, interact with the OpenAI API, and limit the number of concurrent API calls. These utilities can be used throughout the project to ensure efficient and controlled execution of various tasks.\n\n### APIRateLimit.ts\n\nThe `APIRateLimit` class helps manage and limit the number of concurrent API calls made by the application. This is useful when the API has a rate limit or when the application needs to control the number of simultaneous requests to avoid overloading the server. Here's an example of how this class can be used:\n\n```typescript\nconst apiRateLimiter = new APIRateLimit(10); // Limit to 10 concurrent calls\n\nasync function fetchData(id: number): Promise<Data> {\n  // Make an API call to fetch data for the given ID\n}\n\nasync function fetchMultipleData(ids: number[]): Promise<Data[]> {\n  const results = await Promise.all(ids.map(id => apiRateLimiter.callApi(() => fetchData(id))));\n  return results;\n}\n```\n\nIn this example, the `APIRateLimit` class is used to limit the number of concurrent calls made by the `fetchMultipleData` function, ensuring that no more than 10 calls are made at the same time.\n\n### LLMUtil.ts\n\nThis code interacts with the OpenAI API to generate embeddings and completions using different language models. Example usage of these functions might involve generating embeddings for text inputs or generating completions for prompts using the specified language models:\n\n```javascript\nconst embedding = await createEmbedding(\"This is a sample text.\");\nconsole.log(embedding);\n\nconst completion = await createCompletion({\n  model: LLMModels.GPT3,\n  prompt: \"Write a short story about a robot.\",\n  temperature: 0.7,\n  max_tokens: 100,\n});\nconsole.log(completion);\n```\n\nThese functions can be used to integrate the OpenAI API's capabilities into the babyagi-ts project, enabling it to generate embeddings and completions for various use cases.\n\n### WaitUtil.ts\n\nThe `wait` and `forTrue` utility functions help manage asynchronous operations in the project by introducing delays and waiting for specific conditions to be met. Example usage of the `wait` function:\n\n```javascript\nasync function example() {\n  console.log(\"Starting...\");\n  await wait(1000); // Wait for 1 second\n  console.log(\"...Finished\");\n}\n```\n\nExample usage of the `forTrue` function:\n\n```javascript\nasync function waitForElement() {\n  const elementExists = () => document.querySelector(\"#my-element\") !== null;\n  try {\n    await forTrue(elementExists);\n    console.log(\"Element found!\");\n  } catch {\n    console.log(\"Element not found after waiting\");\n  }\n}\n```\n\nIn summary, the `src/cli/utils` folder provides utility functions and classes that help manage asynchronous operations, interact with the OpenAI API, and limit the number of concurrent API calls in the babyagi-ts project. These utilities can be used throughout the project to ensure efficient and controlled execution of various tasks.",
  "questions": ""
}